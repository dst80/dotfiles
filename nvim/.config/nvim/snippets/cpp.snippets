extends c

##
## Preprocessor
# #include <...>
snippet incc
	#include <${1:iostream}>
#
snippet binc
	#include <boost/${1:shared_ptr}.hpp>
##
## STL Collections
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	std::vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
##
## STL smart pointers
# std::shared_ptr
snippet mksp
	std::make_shared<${2:T}>(${3});
#
snippet amksp
	auto ${1} = std::make_shared<${2:T}>(${3});
#
snippet tmksp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
# std::unique_ptr
snippet mkup
	std::make_unique<${1:T}>(${2});	
#
snippet amkup
	auto ${1} = std::make_unique<${2:T}>(${3});
#
snippet tmkup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});

##
## Access Modifiers
snippet pri
	private
#
snippet pro
	protected
#
snippet pub
	public
#
snippet fr
	friend
#
snippet mu
	mutable
##
## Class
snippet class
	class ${1:`expand("%:r")`}
	{
	public:
		${2}
	private:
	};
#
snippet iclass
	class ${1:`expand("%:r")`}
	{
	public:
		virtual ~$1 () = default;
		${2}
	private:
	};	

#
snippet ctor
	${1:`expand("%:r")`} (${2}) ${3:= default;}
#
snippet ctorimp
	${1:`expand("%:r")`}::$1 (${2}) 
	{
		${3}
	}
#
snippet cctor
	${1:`expand("%:r")`} (const $1& ${2:rhs}) ${3:= default;}
#
snippet cctorimp
	${1:`expand("%:r")`}::$1 (const $1& ${2:rhs}) 
	{
		${3}
	}
#
snippet mctor
	${1:`expand("%:r")`} ($1&& ${2:rhs}) ${3:= default;}
#
snippet mctorimp
	${1:`expand("%:r")`}::$1 ($1&& ${2:rhs}) 
	{
		${3}
	}
#
snippet dtor
	~${1:`expand("%:r")`} ();
#
snippet vdtor
	virtual ~${1:`expand("%:r")`} () ${2:= default;}

#
snippet cassign
	${1:`expand("%:r")`}& operator= (const $1& ${2:rhs}) ${3:= default;}
#
snippet cassignimp
	${1:`expand("%:r")`}& $1::operator= (const $1& ${2:rhs})
	{
		${3}
	}
#
snippet massign
	${1:`expand("%:r")`}& operator= ($1&& ${2:rhs}) ${3:= default;}
#
snippet massignimp
	${1:`expand("%:r")`}& $1::operator= ($1&& ${2:rhs})
	{
		${3}
	}
#
snippet mfunc0
	${3:void} ${1:`expand("%:r")`}::${2:memberFunction} () 
	{
		${0:${VISUAL}}
	}
#
snippet mfunc
	${4:void} ${1:`expand("%:r")`}::${2:memberFunction} (${3}) 
	{
		${0:${VISUAL}}
	}
#
snippet enum_class
	enum class ${1:enum_type} : ${2:underlying_type}
	{
		${3}
	}

# namespace
#
snippet namesp
	namespace ${1:some_namespace} 
	{
		${0:${VISUAL}}
	} // namespace $1
#
snippet namesp2
	namespace ${1:namespace1} 
	{
	namespace ${2:namespace2} 
	{	
		${0:${VISUAL}}
	} // namespace $2
	} // namespace $1
#
snippet namesp3
	namespace ${1:namespace1} 
	{
	namespace ${2:namespace2} 
	{	
	namespace ${3:namespace3} 
	{	
		${0:${VISUAL}}
	} // namespace $3
	} // namespace $2
	} // namespace $1

#
snippet anamesp
	namespace 
	{
		${0}
	}
##
## Casts
snippet static_cast
	static_cast<${1:unsigned}>(${2:expr});
#
snippet dynamic_cast
	dynamic_cast<${1:unsigned}>(${2:${VISUAL}});
#
snippet reinterpret_cast
	reinterpret_cast<${1:unsigned}>(${2:${VISUAL}});
#
snippet const_cast
	const_cast<${1:unsigned}>(${2:${VISUAL}});
#
## Iteration
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; {3:++}$2$) 
	{
		${4:${VISUAL}}
	}
#
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) 
	{
		${4:${VISUAL}}
	}
#
snippet iter
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) 
	{
		${4:${VISUAL}}
	}
#
## algorithm
#
snippet all_of
	std::all_of (${1:container}.begin (), $1.end(), ${2:func});
#
snippet any_of
	std::any_of (${1:container}.begin (), $1.end(), ${2:func});
#
snippet none_of
	std::none_of (${1:container}.begin (), $1.end(), ${2:func});
#
snippet count_if
	std::count_if (${1:container}.begin (), $1.end(), ${2:func});
#
snippet find_if
	std::find_if (${1:container}.begin (), $1.end(), ${2:func});
#
snippet afind_if
	auto found = std::find_if (${1:container}.begin (), $1.end(), ${2:func});
#
snippet find_if_not
	std::find_if_not (${1:container}.begin (), $1.end(), ${2:func});
#
snippet afind_if_not
	auto found = std::find_if_not (${1:container}.begin (), $1.end(), ${2:func});
#
snippet for_each
	std::for_each (${1:container}.begin (), $1.end(), ${2:func});
#
snippet transform
	std::transform (${1:container}.begin (), $1.end(), ${2:container2}.begin (), ${3:func});
#
snippet begin_end
	${1:container}.begin (), $1.end()
#
snippet begin_end_do
	${1:container}.begin (), $1.end(), ${2:func}
#
snippet begin_end_begin_do
	${1:container}.begin (), $1.end(), ${2:container2}.begin (), ${3:func}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[${1}](${2})
	{
		${3}
	};
# snippets exception
snippet try
	try {

	}catch(const ${1}& ${2}) {

	}
# auto function
snippet af auto function
	auto ${1:name}(${2}) -> ${3:void}
	{
		${0}
	};

##
## GoogleTest
#
snippet gtest_class
	#include<gmock/gmock-matchers.h>
	#include<gtest/gtest.h>

	class ${1:`expand("%:r")`}Test : public ${2:Test}
	{
		protected:
			
			${3:ClassToTest} ${4:classToTest}_; 
	};

	TEST_F($1, InitializeDoNotFail)
	{
		${3}
	}
#
snippet gTest
	::testing::Test
#
snippet gTestWithParam
	::testing::TestWithParam<${1:TestParameter}>
#
snippet gWithParamInterface
	::testing::WithParamInterface<${1:TestParameter}>
#
snippet gtest_f
	TEST_F(${1:`expand("%:r")`}, ${2:TestCase})
	{
		${3}
	}
#
snippet gtest_p
	TEST_P(${1:`expand("%:r")`}, ${2:TestCase})
	{
		${3}
	}
#
snippet gInstantiateTestSuite
	INSTANTIATE_TEST_SUITE_P(
    ${1:TestInstantiation}, ${2:TestSuite},
    ::testing::Values(
			${3:TestParameter}{${4:Parameters}}${5:,}
		));
#
snippet gAddParam
			${1:TestParameter}{${2:Parameters}}${3:,}
#
snippet assert
	ASSERT_THAT (${1}, ${2})
#
snippet Not
	Not (${0:${VISUAL}})
#
snippet Eq
	Eq (${0:${VISUAL}})
#
snippet IsNull
	IsNull ()
#
snippet NotNull
	NotNull ()	
#
snippet IsFalse
	IsFalse ()
#
snippet IsTrue
	IsTrue ()
#
snippet Ne
	Ne (${1:${VISUAL}})
#
snippet Ge
	Ge (${1:${VISUAL}})
#
snippet Gt
	Ge (${1:${VISUAL}})
#
snippet Le
	Le (${1:${VISUAL}})	
#
snippet DoubleEq
	DoubleEq (${1:${VISUAL}})
#
snippet FloatEq
	FloatEq (${1:${VISUAL}})
#
snippet DoubleNear
	DoubleEq (${1:${VISUAL}}, ${2})
#
snippet FloatNear
	FloatEq (${1:${VISUAL}}, ${2})

#
snippet IsEmpty
	IsEmpty ()

#
snippet SizeIs
	SizeIs (${1})
#
snippet Each
	Each (${1})
#
snippet Contains
	Contains (${1})
#
snippet ContainsTimes
	Contains (${1}).Times (${2})
#
snippet ContainerEq
	ContainerEq (${1})
#
snippet ElementsAre
	ElementsAre ({${1}})	
#
snippet ElementsAreArray
	ElementsAreArray (${1})
#
snippet Pointwise
	Pointwise (${1}, ${2:${VISUAL}})

#
snippet StrEq
	StrEq (${1})	
#
snippet StrNe
	StrNe (${1})	
#
snippet StrCaseEq
	StrCaseEq (${1})	
#
snippet StrCaseNe
	StrCaseNe (${1})
#
snippet StartsWith
	StartsWith (${1})
#
snippet EndsWith
	EndsWith (${1})	
#
snippet HasSubstr
	HasSubstr (${1})		
#
snippet ContainsRegex
	ContainsRegex (${1})
#
snippet MatchesRegex
	MatchesRegex (${1})


##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} ${2:<< std::endl};
# std::cin
snippet cin
	std::cin >> ${1};
# std::cin
snippet cerr
	std::cerr << ${1} ${2:<< std::endl};
