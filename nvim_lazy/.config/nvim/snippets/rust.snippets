# Functions
#
snippet fn "Function definition"
	fn ${1:function_name}(${2})${3} {
		${0}
	}
#
snippet pfn "Function definition"
	pub fn ${1:function_name}(${2})${3} {
		${0}
	}
#
snippet afn "Async function definition"
	async fn ${1:function_name}(${2})${3} {
		${0}
	}
#
snippet pafn "Async function definition"
	pub async fn ${1:function_name}(${2})${3} {
		${0}
	}
#
snippet bench "Bench function" b
	#[bench]
	fn ${1:bench_function_name}(b: &mut test::Bencher) {
		b.iter(|| {
			${0}
		})
	}
#
snippet new "Constructor function"
	pub fn new(${2}) -> ${1:Self} {
		$1 { ${3} }
	}
#
snippet main "Main function"
	pub fn main() {
		${0}
	}
#
snippet let "let variable declaration with type inference"
	let ${1} = ${2};
#
snippet let_t "let variable declaration with explicit type annotation"
	let ${1}: ${2} = ${3};
#
snippet let_mut "let mut variable declaration with type inference"
	let mut ${1} = ${2};
#
snippet let_mut_t "let mut variable declaration with explicit type annotation"
	let mut ${1}: ${2} = ${3};
#
snippet print "print!"
	print!("${1}");
#
snippet print, "print! with format param"
	print!("${1}{${2}}", ${3});
#
snippet println "println!"
	println!("${1}");
#
snippet println, "println! with format param"
	println!("${1}{${2}}", ${3});
#
snippet format "format!"
	format!("${1}{${2}}", ${3});
#
snippet dbg "dbg! debugging macro"
	dbg!(${0:${VISUAL}})
#
snippet dbg; "dbg! debugging macro statement"
	dbg!(&${1});
	${0}
# Modules
#
snippet extern_crate "extern crate"
	extern crate ${1:sync};
#
snippet extern_crate_log "extern crate log"
	#[macro_use]
	extern crate log;
#
snippet mod
	mod ${1:`expand("%:r")`} {
		${0}
	} /* $1 */
# Testing
#
snippet assert "assert!"
	assert!(${1:predicate});
#
snippet assert_eq "assert_eq!"
	assert_eq!(${1:expected}, ${2:actual});
#
snippet test "Unit test function"
	#[test]
	fn ${1:function_name}_test() {
		${0}
	}
#
snippet testmod "Test module" b
	#[cfg(test)]
	mod tests {
		use super::${1:*};

		test${0}
	}
#
snippet ignore "#[ignore]"
	#[ignore]
# Attributes
#
snippet allow "allow lint attribute" b
	#[allow(${1:unused_variables})]
#
snippet cfg "cfg attribute" b
	#[cfg(${1:target_os = "linux"})]
#
snippet feature "feature attribute" b
	#![feature(${1:plugin})]
#
snippet derive "#[derive(..)]" b
	#[derive(${1:Debug})]
#
snippet attrib "#[..]" b
	#[${1:inline}]
#
snippet crate "Define create meta attributes"
	// Crate name
	#![crate_name = "${1:crate_name}"]
	// Additional metadata attributes
	#![desc = "${2:Description.}"]
	#![license = "${3:BSD}"]
	#![comment = "${4:Comment.}"]
	// Specify the output type
	#![crate_type = "${5:lib}"]
# Common types
snippet option "Option<T>"
	Option<${1:i32}>
#
snippet result "Result<T, E>"
	Result<${1:&str}, ${2:()}>
# Control structures
snippet if
	if ${1} {
		${0:${VISUAL}}
	}
#
snippet if_let "if let (...)"
	if let ${1:Some($2)} = $3 {
		${0:${VISUAL}}
	}
#
snippet else "else"
	else {
		${0:${VISUAL}}
	}
#
snippet else_if "else if"
	else if ${1} {
		${0:${VISUAL}}
	}
#
snippet match "match pattern"
	match ${1} {
		${2} => ${3}
	}
#
snippet case "Case clause of pattern match"
	${1:_} => ${2:expression}
#
snippet = "=> "
	=> $0
#
snippet loop "loop {}" b
	loop {
		${0:${VISUAL}}
	}
#
snippet while "while loop"
	while ${1:condition} {
		${0:${VISUAL}}
	}
#
snippet while_let "while let (...)"
	while let ${1:Some($2)} = $3 {
		${0:${VISUAL}}
	}
#
snippet for "for ... in ... loop"
	for ${1:i} in ${2} {
		${0}
	}
# TODO commenting
snippet todo "TODO comment"
	// TODO: $0
y
snippet fixme "FIXME comment"
	// FIXME: $0
# Struct
#
snippet stuct "Struct definition"
	struct ${1:`expand("%:r")`} {
		${0}
	}
#
snippet impl "Struct/Trait implementation"
	impl ${1:Type/Trait}${2: for $3} {
		${0}
	}
#
snippet stuct_new "Struct with new constructor"
	pub struct ${1:`expand("%:r")`} {
		${0}
	}

	impl$2 $1$2 {
		pub fn new(${4}) -> Self {
			$1 { ${5} }
		}
	}
#
snippet type "Type alias"
	type ${1:NewName} = $2;
#
snippet enum "enum definition"
	enum ${1:Name} {
		${2},
	}
#
snippet penum "pub enum definition"
	pub enum ${1:Name} {
		${2},
	}
# Traits
snippet trait "Trait definition"
	trait ${1:Name} {
		${0}
	}
#
snippet drop "Drop trait implementation (destructor)"
	impl Drop for $1 {
		fn drop(&mut self) {
			${0}
		}
	}
# Statics
snippet static "static item declaration"
	static ${1}: ${2:usize} = ${0};
#    
snippet static_string "static string declaration"
	static ${1}: &'static str = "${0}";
# Concurrency
snippet spawn "spawn a thread"
	thread::spawn(${1:move }|| {
		${0}
	});
#
snippet channel "Declare (Sender, Receiver) pair of asynchronous channel()"
	let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();
# Implementations
snippet asref "AsRef trait implementation"
	impl AsRef<${1:Ref}> for ${2:Type} {
		fn as_ref(&self) -> &${3:$1} {
			&self.${0:field}
		}
	}
#
snippet asmut "AsMut trait implementation"
	impl AsMut<${1:Ref}> for ${2:Type} {
		fn as_mut(&mut self) -> &mut ${3:$1} {
			&mut self.${0:field}
		}
	}
#
snippet fd "Struct field definition" w
	${1:name}: ${2:Type},
#
snippet || "Closure, anonymous function (inline)" i
	${1:move }|$2| { $3 }
#
snippet |} "Closure, anonymous function (block)" i
	${1:move }|$2| {
		$3
	}
#
snippet macro "macro_rules!" b
	macro_rules! ${1:name} {
		(${2:matcher}) => (
			$3
		)
	}
#
snippet boxp "Box::new()"
	Box::new(${0:${VISUAL}})
#
snippet rc "Rc::new()"
	Rc::new(${0:${VISUAL}})
#
snippet unimplemented "unimplemented!()"
	unimplemented!()
#
snippet use "use ...;" b
	use ${1:std::$2};